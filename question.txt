java 160 строка.
1. Какая размерность у boolean?
Логический тип несет в себе один бит информации, но размер переменной не определен точно, и завивит от виртуальной машины.

2. Как добавить String’у в pool строк?
Если строка создана с помощью конструктора или после компиляции, она хранится в памяти, называемой куча(heap). Если строка создана как литерал (строки в пул помещаются во время компиляции), то она хранится в специальном месте кучи - пуле строк (pool). В нем хранятся уникальные значения.  Помещение строк в пул - интернирование. Вручную можно добавить строку в пул методом inter(). Но ручное добавление строки в пул снижает производительность.

3. Какие есть циклы в Java? Чем отличаются друг от друга?
    - цикл for. в общем виде цикл выглядит так:
    for(;;) {
        \\
    }
    - цикл с предусловием:
     while (condition) {
        \\
    }
    - цикл с постусловием:
    do {
        \\
    } while(condition);
    - итератор коллекции, для выполнения действий над каждым элементом коллекции:
    foreach(type i : iter[]) {
        \\
    }

4. Что такое рекурсия? Недостатки и преимущества?
Рекурсия - это метод, который вызывает сам себя.
Недостатки рекурсии:
При каждом вызове рекурсии в стеке выделяется новая память под хранение переменных в стеке, при завершении метода, память освобождается. Соответственно, рекурсия использует больше памяти и выполняется медленнее.
Так же стек может переполнится.
Преимущества: Решение с помощью рекурсии проще и требует меньше времени на реализацию.

5. Переведи число X (любое) из десятичной в двоичную, и число Y (любое) из двоичной в десятичную

6. Какие классы-обертки знаешь?
Классы-обертки - специальный класс, который хранит в себе значение примитива. Основное их преимущество по сравнению с примитивами - наличие методов.
Так же у классов-оберток есть статические поля: например, минимальное значение для Integer - MIN_VALUE.
Классы обертки: Integer, Short, Long, Byte, Float, Double, Character, Boolean

7. Расскажи про pool строк и pool примитивов
pool строк: Если строка создана с помощью конструктора или после компиляции, она хранится в памяти, называемой куча(heap). Если строка создана как литерал (строки в пул помещаются во время компиляции), то она хранится в специальном месте кучи - пуле строк (pool). В нем хранятся уникальные значения. Помещение строк в пул - интернирование. Вручную можно добавить строку в пул методом inter(). Но ручное добавление строки в пул снижает производительность.

pool примитивов: При объявлении переменной классом-оберткой без использования конструктора new, переменная будет ссылаться на значение из пула.
Boolean：true，false
Byte：-127~128
Character：0~127
Short，Integer，Long：-128~127
Float, Double: нет постоянного пула

Отсюда вытекает интересное поведение:
Intger x = 10;
Intger y = 10;
x == y; //true

Intger x = 140;
Intger y = 140;
x == y; //false

5. Разница между String, StringBuilder и StringBuffer?
String - неизменяемый класс. Это final класс, то есть не может быть переопределн в подклассах. Т.к. класс неизменяется, его хешкод кешируется - это дает высокую производительность при использовании его в качестве ключа в hashmap. String можно использовать в многопоточной среде без доп. синхронизации. Для него перегружен оператор "+". Т.к. строки неизменяемые, при выполнении действий над ними создаются новые строки, а старые отбрасываются, порждая мусор.
StringBuffer - изменяемый класс, который содержит в себе определенный набор символов, длинну и значение которых можно изменить. Этот класс пораждает меньше мусора, чем String. Это потокобезопасный класс, т.е. его методы могут быть использованы несколькими потоками одновременно.
Недостаток - он медленнее, т.к. синхронизированные методы медленнее несинхронизированных.
StringBuilder очень похож на StringBuffer, за исключением потокобезопасности - это его основное отличие.

6. Какая максимальная длина массива?
Т.к. в массивы индексируются целыми числами, то максимальная длинна массива ограничена максимальным значением integer - х (х от 2 до 5 в разных источниках). Кроме того в качестве ограничения выступает объем памяти, доступный для программы.

7. Почему 0.1 + 0.7 != 0.8 ?
Из-за того, что в двоичной системе нельзя представить математически точно числа с плавающей запятой.Например, 0.1 - это 0.100000000000000005551115123126. Кроме того, float и double ограничены в представлении чисел 32 и 64 битам соответственно - остальная часть будет попросту обрезаться. Если нужны очень точный вычисления, то следует использовать BigDecimal.

8. При сложении char short какой результирующий тип получим?
Результирующий тип int. При выполнении арифметический операций выполняется неявное преобразование типов по слудеющему правилу:
	#1. Если один из операндов double, то остальные преобразуются к double.
	#2. Если 1 не соблюдено, и один из типов float, то остальные преобразуются к float
	#3. Если 2 не соблюдено, но есть long, то остальные преобразуются к long
	#4. Иначе, все преобразуются к int;

Отличие операторов сокращенных логических операторов и полных
Существуют сокращенные (или условные) операторы дизъюнкции (ИЛИ) и конъюнкции (&). Отличие от полных операторов:
	#1. Условное ИЛИ - если оператор слева от || имеет значение true, то оператор справа не вычисляется
	#2. Условное И - если оператор слева от && имеет значение false, то оператор справа не вычисляется

Приоритет:
	#1. !
	#2. &
	#3. ^
	#4. |
	#5. &&
	#6. || 


9. Где находятся параметры и аргументы метода
Параметр - это переменная, определенная методом, которая принимает значение при вызове метода.
Аргумент - это значение, передаваемое методу при его вызове.
Соответственно, параметры указываются при объявлении метода, аргумены - при его вызове.

10. Все примитивные типы и их размеры
byte целочисленный (8 бит)
short целочисленный (16 бит)
int целочисленный (32 бит)
long целочисленный (64 бит)
float с плавающей точкой (32 бит)
double с плавающей точкой (64 бит)
boolean - имеет значения true и false, но сколько занимает памяти зависит от JVM
char - (16 бит) Представляет собой код символа в Unicode, но по сути является числом и поддерживает математические действия

11. Потери при неявных приведениях
Может быть потеря точности при приведение int или long к float (из-за нехватки значащих цифр)
Кроме того, потери могут случится при использовании операторов +=; *=; -= - при использовании этих операторов не происходит приведение к большему типу.
Например:
short s = 3;
s += 4.6; // s = 7
или
int i 1234567890;
i+= 12345678902347L; // i = -1117505763

12. Что такое Autoboxing, unboxing и когда они происходят автоматически?
Autoboxing (Автоупаковка) - автоматическая инкапсуляция примитивного типа в его Классы-обертку.
Autoboxing происходит:
	- При присвоении значения примитивного типа переменной соответствующего класса-обёртки.
	- При передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.

Это преобразование класса-обёртки в соответствующий ему примитивный тип. Если при распаковке класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException.
Unboxing происходит:
При присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа.
В выражениях, в которых один или оба аргумента являются экземплярами классов-обёрток (кроме операции == и !=).
При передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.
















4. Что такое continue и break? Расширенная версия ?"
"1) Перевод 1111 в десятичную систему и обратно
2) Оператор XOR. Представить таблицу истинности для него
3) autoboxing unboxing"
"1) Какие примитивные типы есть в Java
2) Что такое явные и неявные приведения, с чем связано их наличие?
3) Какие данные мы рискуем потерять при явных приведениях?
4) StringBuilder.
5) Логические операторы.
6) char
7) Неизменяемые типы"
"1. Какая размерность у boolean?
2. Почему 0.1 0.7 != 0.8 ?
3. При сложении char short какой результирующий тип получим?
4. Почему не рекомендуются множественные конкатенации String?
5. чем отличается метод от функции?
6. можно ли положить максимальное значение long во float"
"1. Какая размерность у boolean?
2. byte a = 1; byte b = 2; byte c = a b; Будут ли какие-то проблемы?
3. При сложении char short какой результирующий тип получим?
4. Как добавить String’у в pool строк?
5. Расскажи про pool строк и pool примитивов
6. чем отличается метод от функции?
7. Что такое массив и какие на нём есть ограничения?
8. Расскажи про все условные операторы?"
"1. Отличия for от for each
2. Потеря данных при преобразовании short/char
3. Все условные операторы
4. Инкременты, декременты, отличия.
5. Пулы строк и integer
6. чем отличается метод от функции?"
"1. Почему 0.1 + 0.7 != 0.8 ?
2. Что такое массив и какие на нём есть ограничения?
3. Какая максимальная длина массива?
4. Что такое рекурсия? Недостатки и преимущества?
5. 2 случая (правила/условия) в рекурсивном алгоритме?"
"1. Какая размерность у boolean?
2. Почему 0.1 0.7 != 0.8 ?
3. Что такое char? Почему над ним можно выполнять арифметические операции?
4. Какие могут быть потери данных при явных привидениях?
5. Double to int
6. Что такое массив и какие на нём есть ограничения?
7. Какая максимальная длина массива?
8. Расширенный break"